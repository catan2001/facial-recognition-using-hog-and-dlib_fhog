# Universal Verification Methodology (UVM)

## Verification of HOG

## UVM Guidelines and Hierarchy

### 1. **UVM Sequence Item**

#### Purpose:
The sequence item is the fundamental data structure in UVM, representing a transaction or operation that needs to be performed by the DUT (Design Under Test).

#### Role:
- **Definition of Data**: It defines the data fields necessary for a transaction, like address, data, control signals, etc.
- **Communication**: The sequence item is passed between different components of the UVM environment, especially from the sequence to the driver.
- **Randomization**: Sequence items can be randomized to create a wide variety of scenarios to test different aspects of the DUT.

### 2. **UVM Sequence**

#### Purpose:
The sequence is responsible for generating a series of sequence items. It defines the order in which these items are created and how they are sent to the DUT.

#### Role:
- **Transaction Generation**: Sequences create transactions based on the test requirements.
- **Scenario Definition**: Different sequences can be used to model various scenarios, such as typical operation, stress tests, or edge cases.
- **Interaction with Sequencer**: Sequences communicate with the sequencer to send the generated transactions to the driver.

### 3. **UVM Sequencer**

#### Purpose:
The sequencer manages the flow of sequence items from the sequence to the driver. It acts as a mediator, ensuring that transactions are provided to the driver in a controlled manner.

#### Role:
- **Arbitration**: When multiple sequences are running concurrently, the sequencer decides the order in which transactions are passed to the driver.
- **Flow Control**: The sequencer controls the timing and flow of transactions, ensuring that they are sent to the driver as needed.
- **Flexibility**: Different sequencers can be used for different types of transactions or protocol layers in more complex environments.

### 4. **UVM Driver**

#### Purpose:
The driver converts the high-level sequence items into the actual signal-level operations needed to interact with the DUT. It is the component that drives the signals based on the transactions generated by the sequences.

#### Role:
- **Signal Generation**: The driver takes the abstract transactions from the sequence item and drives the appropriate signals on the DUT’s interface.
- **Protocol Handling**: The driver ensures that the signals are driven according to the protocol’s timing and sequence rules.
- **Response Handling**: Depending on the protocol, the driver may also collect responses from the DUT and pass them back to the sequencer or sequence.

### 5. **UVM Monitor**

#### Purpose:
The monitor passively observes the DUT’s behavior and captures the signal activity, converting it back into high-level transactions.

#### Role:
- **Passive Observation**: Monitors observe the signals on the DUT without driving them, ensuring that the DUT’s operations are captured without interference.
- **Transaction Conversion**: They convert the observed signal activity back into sequence items (transactions) that can be checked against expected behavior.
- **Analysis**: Monitors often send the captured transactions to checkers, scoreboards, or coverage collectors for further analysis and verification.

### 6. **UVM Scoreboard**

#### Purpose:
The scoreboard compares the actual transactions observed by the monitor with the expected transactions to determine if the DUT is behaving correctly.

#### Role:
- **Data Comparison**: The scoreboard receives transactions from the monitor and compares them with a reference model or expected data.
- **Error Detection**: If there is a discrepancy between the observed and expected transactions, the scoreboard flags it as an error.
- **Reporting**: The scoreboard logs these errors for further analysis, helping to identify issues in the DUT.

### 7. **UVM Environment**

#### Purpose:
The environment is a container that encapsulates the various components (such as sequencers, drivers, monitors, and scoreboards) that make up the UVM testbench. It defines how these components are connected and interact with each other.

#### Role:
- **Organization**: The environment organizes and connects all the necessary components of the testbench, creating a cohesive structure.
- **Reusability**: Environments can be reused across different tests, making the verification process more efficient.
- **Integration**: It integrates all the components, ensuring they work together to generate, drive, observe, and analyze transactions.

### 8. **UVM Test**

#### Purpose:
The test is the top-level component that configures the environment and controls the execution of sequences. It represents a specific test scenario or use case for the DUT.

#### Role:
- **Configuration**: The test sets up the environment and its components according to the specific requirements of the test scenario.
- **Sequence Control**: It controls which sequences are run, how they are applied, and under what conditions.
- **Execution**: The test triggers the run-time phases, initiating the sequences and managing the overall flow of the test.

### 9. **Top-Level Module**

#### Purpose:
The top-level module is the entry point to the simulation, where the DUT is instantiated and connected to the UVM testbench.

#### Role:
- **Instantiation**: It instantiates both the DUT and the UVM testbench components.
- **Connection**: The top-level module connects the DUT to the UVM environment via virtual interfaces or direct connections.
- **Simulation Control**: It controls the start of the simulation by invoking the UVM test, effectively launching the verification process.

### 10. **UVM Checker**

#### Purpose:
The checker ensures that specific conditions or properties hold true during the simulation. It is used to verify protocol compliance, data integrity, and other correctness criteria.

#### Role:
- **Property Verification**: Checkers can be used to verify that certain properties, such as protocol rules or timing constraints, are met.
- **Protocol Compliance**: In protocol verification, checkers ensure that the DUT adheres to the protocol’s rules and guidelines.
- **Error Detection**: If a property or condition is violated, the checker flags it as an error, helping to identify bugs in the DUT.

### 11. **UVM Coverage**

#### Purpose:
Coverage collects data on which parts of the DUT or which scenarios have been exercised during the simulation. It is a measure of how thoroughly the DUT has been tested.

#### Role:
- **Coverage Collection**: Coverage can be collected at various levels, such as functional coverage (did specific scenarios occur?) and code coverage (were all lines of code executed?).
- **Coverage Analysis**: The collected coverage data is analyzed to determine how well the DUT has been tested and to identify areas that may need more testing.
- **Test Effectiveness**: Coverage provides feedback on the effectiveness of the testbench, guiding the creation of additional tests to improve verification completeness.

---

In summary:
- **Sequence Item, Sequence, Sequencer, and Driver** form the core transaction flow in the testbench.
- **Monitor, Checker, and Scoreboard** observe, check, and compare DUT behavior.
- **Environment and Test** provide structure and control over the testbench.
- **Top-Level Module** integrates the DUT with the testbench.
- **Coverage** ensures that the verification is comprehensive.

Together, these components create a flexible and powerful UVM testbench capable of verifying complex DUTs.

## Call Hierarchy

In the UVM testbench for the AXI Lite protocol, understanding the sequence of calls between components is essential to grasp how the testbench drives, observes, and verifies the Design Under Test (DUT). Here's a detailed explanation of the flow, outlining who calls who and when, step by step:

### 1. **Top-Level Module**

- **Who and When**: The top-level module starts the simulation by invoking the UVM test environment.
- **What Happens**: 
  - The DUT is instantiated and connected to the UVM testbench via the virtual interface.
  - The UVM test is started using the `run_test()` call, which kicks off the UVM run-time phases.

### 2. **UVM Test**

- **Who and When**: The test is started by the UVM run-time environment as soon as `run_test()` is called in the top-level module.
- **What Happens**:
  - **Build Phase**: The test creates and configures the UVM environment. It instantiates the environment, which in turn builds all its sub-components (sequencer, driver, monitor, etc.).
  - **Run Phase**: The test triggers the execution of sequences by starting the sequence on the sequencer. It calls `seq.start(env.sequencer)` to initiate the sequence.

### 3. **UVM Environment**

- **Who and When**: The environment is instantiated and configured during the build phase of the test.
- **What Happens**:
  - **Build Phase**: It instantiates all the required components (driver, monitor, sequencer).
  - **Connect Phase**: It connects the ports of the sequencer, driver, and monitor to ensure proper communication between them.
  
### 4. **UVM Sequence**

- **Who and When**: The sequence is started by the test during the run phase.
- **What Happens**:
  - **Execution**: The sequence generates transactions (sequence items) and sends them to the sequencer.
  - **Interaction with Sequencer**: It calls methods like `start_item(trans)` and `finish_item(trans)` to send each transaction to the sequencer.

### 5. **UVM Sequencer**

- **Who and When**: The sequencer is part of the environment, connected to the sequence and the driver.
- **What Happens**:
  - **Transaction Flow**: It receives transactions from the sequence and queues them for the driver.
  - **Interaction with Driver**: The sequencer uses the `seq_item_export` to send transactions to the driver, allowing the driver to fetch transactions as needed.

### 6. **UVM Driver**

- **Who and When**: The driver is called by the sequencer when transactions are available.
- **What Happens**:
  - **Execution**: The driver fetches transactions from the sequencer’s `seq_item_export` using methods like `get_next_item()`.
  - **Signal Driving**: It converts the transactions into the appropriate signal-level operations on the DUT’s interface using the virtual interface.
  - **Completion Notification**: Once a transaction is driven, the driver notifies the sequencer using `item_done()`.

### 7. **UVM Monitor**

- **Who and When**: The monitor operates continuously and passively; it observes the DUT’s signal activity throughout the run phase.
- **What Happens**:
  - **Observation**: The monitor captures signal changes on the DUT’s interface.
  - **Transaction Conversion**: It converts the observed signals back into high-level transactions (similar to sequence items).
  - **Reporting**: The monitor sends these transactions to other components like the scoreboard via analysis ports.

### 8. **UVM Scoreboard**

- **Who and When**: The scoreboard receives transactions from the monitor as they occur.
- **What Happens**:
  - **Comparison**: It compares the observed transactions against expected results, which might come from a reference model or predetermined expected values.
  - **Error Reporting**: If discrepancies are found, the scoreboard logs errors, helping to identify failures in the DUT’s behavior.

### 9. **UVM Checker (If Used)**

- **Who and When**: Checkers can be called by the monitor, driver, or scoreboard depending on where specific protocol checks are needed.
- **What Happens**:
  - **Verification**: Checkers verify specific properties or conditions on the transactions, ensuring protocol compliance or data integrity.
  - **Error Detection**: They flag errors if any properties or conditions are violated.

### 10. **UVM Coverage (If Used)**

- **Who and When**: Coverage collectors are typically called by the monitor or within the sequence to collect coverage data throughout the simulation.
- **What Happens**:
  - **Coverage Collection**: They gather data on which scenarios were exercised, ensuring that the testbench is thorough.
  - **Analysis**: This data is used to assess the effectiveness of the test and guide additional testing efforts.

### Summary of Flow

1. **Top-Level Module** starts the UVM test.
2. **UVM Test** creates the environment and starts the sequence.
3. **UVM Environment** builds and connects components (driver, monitor, sequencer).
4. **UVM Sequence** generates transactions and interacts with the sequencer.
5. **UVM Sequencer** passes transactions from the sequence to the driver.
6. **UVM Driver** drives the transactions as signals on the DUT interface.
7. **UVM Monitor** observes DUT behavior, converting signals back to transactions.
8. **UVM Scoreboard** checks the observed transactions against expected outcomes.
9. **UVM Checker** verifies specific conditions or properties (if used).
10. **UVM Coverage** collects data on scenario coverage (if used).

This flow ensures a structured approach to verification, allowing systematic generation, driving, observation, and checking of the DUT’s behavior in a controlled and reusable manner.


## Example AXI Lite (short version)


### 1. **AXI Lite Sequence Item**

The sequence item is the data structure representing a transaction.

```systemverilog
class axi_lite_seq_item extends uvm_sequence_item;
   // Define a axi_lite_seq_item class that extends uvm_sequence_item for AXI Lite transactions

   rand bit [31:0] address;
   // Randomizable address field for the AXI Lite transaction

   rand bit [31:0] data;
   // Randomizable data field for the AXI Lite transaction

   rand bit        write_enable;
   // Randomizable field to indicate if the transaction is a write (1) or read (0)

   function new(string name = "axi_lite_seq_item");
      // Constructor for the transaction item
      super.new(name);
      // Call the base class constructor with the optional name argument
   endfunction

   `uvm_object_utils(axi_lite_seq_item)
   // Register the axi_lite_seq_item with the UVM factory
endclass
```

### 2. **AXI Lite Sequence**

The sequence generates a series of transactions.

```systemverilog
class axi_lite_sequence extends uvm_sequence #(axi_lite_seq_item);
   // Define a sequence class that extends uvm_sequence and operates on axi_lite_transaction items
   `uvm_object_utils(axi_lite_sequence)
   // Register the sequence with the UVM factory

   function new(string name = "axi_lite_sequence");
      // Constructor for the sequence
      super.new(name);
      // Call the base class constructor with the optional name argument
   endfunction

   virtual task body();
      // The main task that defines the sequence of operations
      axi_lite_seq_item trans;
      // Declare a variable to hold the transaction item

      trans = axi_lite_seq_item::type_id::create("trans");
      // Create a new transaction item using the UVM factory

      // Example: Generate a write transaction
      trans.address = 32'h0000_0004;
      // Set the address for the write transaction

      trans.data = 32'hDEADBEEF;
      // Set the data to be written

      trans.write_enable = 1;
      // Indicate that this is a write transaction

      start_item(trans);
      // Notify the sequencer that a new item is ready to be sent

      finish_item(trans);
      // Notify the sequencer that the item is complete

      // Example: Generate a read transaction
      trans.address = 32'h0000_0004;
      // Set the address for the read transaction

      trans.write_enable = 0;
      // Indicate that this is a read transaction

      start_item(trans);
      // Notify the sequencer that a new item is ready to be sent

      finish_item(trans);
      // Notify the sequencer that the item is complete
   endtask
endclass
```

### 3. **AXI Lite Sequencer**

The sequencer coordinates the flow of sequence items to the driver.

```systemverilog
class axi_lite_sequencer extends uvm_sequencer #(axi_lite_seq_item);
   // Define a sequencer class that extends uvm_sequencer and operates on axi_lite_seq_item items
   `uvm_component_utils(axi_lite_sequencer)
   // Register the sequencer with the UVM factory

   function new(string name, uvm_component parent);
      // Constructor for the sequencer
      super.new(name, parent);
      // Call the base class constructor with the name and parent arguments
   endfunction
endclass
```

### 4. **AXI Lite Driver**

The driver translates sequence items into signal-level operations on the DUT.

```systemverilog
class axi_lite_driver extends uvm_driver #(axi_lite_seq_item);
   // Define a driver class that extends uvm_driver and operates on axi_lite_seq_item items
   `uvm_component_utils(axi_lite_driver)
   // Register the driver with the UVM factory

   // Virtual interface to the DUT
   virtual axi_lite_if vif;

   function new(string name, uvm_component parent);
      // Constructor for the driver
      super.new(name, parent);
      // Call the base class constructor with the name and parent arguments
   endfunction

   virtual task run_phase(uvm_phase phase);
      // The main task that drives transactions to the DUT during the run phase
      axi_lite_seq_item trans;
      // Declare a variable to hold the axi_lite_seq_item

      forever begin
         // Infinite loop to continuously drive transactions
         seq_item_port.get_next_item(trans);
         // Get the next transaction item from the sequencer

         // Example: Drive write transaction
         if (trans.write_enable) begin
            vif.awaddr <= trans.address;
            // Drive the address to the AWADDR channel of the AXI Lite interface

            vif.wdata <= trans.data;
            // Drive the data to the WDATA channel of the AXI Lite interface

            vif.awvalid <= 1;
            // Assert AWVALID to indicate a valid address is being driven

            // Handshaking logic and further signal driving would go here
         end else begin
            // Example: Drive read transaction
            vif.araddr <= trans.address;
            // Drive the address to the ARADDR channel of the AXI Lite interface

            vif.arvalid <= 1;
            // Assert ARVALID to indicate a valid address is being driven

            // Handshaking logic and further signal driving would go here
         end

         seq_item_port.item_done();
         // Notify the sequencer that the current transaction is done
      end
   endtask
endclass
```

### 5. **AXI Lite Monitor**

The monitor observes the signals driven by the DUT and checks for correctness.

```systemverilog
class axi_lite_monitor extends uvm_monitor;
   // Define a monitor class that extends uvm_monitor
   `uvm_component_utils(axi_lite_monitor)
   // Register the monitor with the UVM factory

   // Virtual interface to the DUT
   virtual axi_lite_if vif;

   uvm_analysis_port #(axi_lite_seq_item) ap;
   // Analysis port to send observed transactions to other components like scoreboards

   function new(string name, uvm_component parent);
      // Constructor for the monitor
      super.new(name, parent);
      // Call the base class constructor with the name and parent arguments
   endfunction

   virtual function void build_phase(uvm_phase phase);
      // The build phase where monitor components are instantiated
      super.build_phase(phase);
      // Call the base class build_phase

      ap = uvm_analysis_port #(axi_lite_seq_item)::type_id::create("ap", this);
      // Create the analysis port
   endfunction

   virtual task run_phase(uvm_phase phase);
      // The main task that observes signals from the DUT during the run phase
      axi_lite_seq_item trans;
      // Declare a variable to hold the transaction item

      forever begin
         // Infinite loop to continuously monitor DUT signals

         // Example: Monitor the write channel
         if (vif.awvalid && vif.awready) begin
            trans = axi_lite_seq_item::type_id::create("trans");
            // Create a new transaction item to capture the observed data

            trans.address = vif.awaddr;
            // Capture the address from the AWADDR channel

            trans.data = vif.wdata;
            // Capture the data from the WDATA channel

            trans.write_enable = 1;
            // Indicate that this is a write transaction

            ap.write(trans);
            // Send the observed transaction to the analysis port
         end

         // Example: Monitor the read channel
         if (vif.arvalid && vif.arready) begin
            trans = axi_lite_seq_item::type_id::create("trans");
            // Create a new transaction item to capture the observed data

            trans.address = vif.araddr;
            // Capture the address from the ARADDR channel

            trans.write_enable = 0;
            // Indicate that this is a read transaction

            ap.write(trans);
            // Send the observed transaction to the analysis port
         end
      end
   endtask
endclass
```

### 6. **AXI Lite Environment**

The environment ties together all components of the testbench.

```systemverilog
class axi_lite_env extends uvm_env;
   // Define an environment class that extends uvm_env
   `uvm_component_utils(axi_lite_env)
   // Register the environment with the UVM factory

   axi_lite_driver driver;
   // Declare a variable to hold the driver

   axi_lite_monitor monitor;
   // Declare a variable to hold the monitor

   axi_lite_sequencer sequencer;
   // Declare a variable to hold the sequencer

   function new(string name, uvm_component parent);
      // Constructor for the environment
      super.new(name, parent);
      // Call the base class constructor with the name and parent arguments
   endfunction

   virtual function void build_phase(uvm_phase phase);
      // The build phase where environment components are instantiated
      super.build_phase(phase);
      // Call the base class build_phase

      driver = axi_lite_driver::type_id::create("driver", this);
      // Create the driver component

      monitor = axi_lite_monitor::type_id::create("monitor", this);
      // Create the monitor component

      sequencer = axi_lite_sequencer::type_id::create("sequencer", this);
      // Create the sequencer component
   end

function

   virtual function void connect_phase(uvm_phase phase);
      // The connect phase where components are connected together
      driver.seq_item_port.connect(sequencer.seq_item_export);
      // Connect the driver's sequence item port to the sequencer's export port

      monitor.ap.connect(driver.analysis_export);
      // Connect the monitor's analysis port to the driver's analysis export
   endfunction
endclass
```

### 7. **AXI Lite Test**

The test configures the environment and triggers the sequence.

```systemverilog
class axi_lite_test extends uvm_test;
   // Define a test class that extends uvm_test
   `uvm_component_utils(axi_lite_test)
   // Register the test with the UVM factory

   axi_lite_env env;
   // Declare a variable to hold the testbench environment

   function new(string name, uvm_component parent);
      // Constructor for the test
      super.new(name, parent);
      // Call the base class constructor with the name and parent arguments
   endfunction

   virtual function void build_phase(uvm_phase phase);
      // The build phase where the environment is instantiated
      super.build_phase(phase);
      // Call the base class build_phase

      env = axi_lite_env::type_id::create("env", this);
      // Create the environment using the UVM factory and assign it to the env variable
   endfunction

   virtual task run_phase(uvm_phase phase);
      // The run phase where the actual test sequence is executed
      axi_lite_sequence seq;
      // Declare a variable to hold the sequence

      seq = axi_lite_sequence::type_id::create("seq");
      // Create the sequence using the UVM factory

      seq.start(env.sequencer);
      // Start the sequence on the environment's sequencer
   endtask
endclass
```

### 8. **Top-Level Module**

The top-level module instantiates the DUT and connects it to the virtual interface used by the UVM testbench.

```systemverilog
module top;
   // Top-level module that instantiates the DUT and connects it to the UVM testbench

   // Declare the virtual interface to be used by UVM components
   virtual axi_lite_if vif;

   // Instantiate the DUT
   axi_lite_dut dut (
      .awaddr(vif.awaddr),
      .awvalid(vif.awvalid),
      .awready(vif.awready),
      .wdata(vif.wdata),
      .wvalid(vif.wvalid),
      .wready(vif.wready),
      .araddr(vif.araddr),
      .arvalid(vif.arvalid),
      .arready(vif.arready)
   );

   // Instantiate the UVM configuration database
   initial begin
      uvm_config_db#(virtual axi_lite_if)::set(null, "env", "vif", vif);
      // Set the virtual interface in the UVM configuration database

      run_test("axi_lite_test");
      // Run the specified UVM test
   end
endmodule
```

### Summary

- **Transaction Item (`axi_lite_seq_item`)**: Defines the structure of an AXI Lite transaction.
- **Sequence (`axi_lite_sequence`)**: Generates transactions.
- **Sequencer (`axi_lite_sequencer`)**: Manages the flow of transactions from the sequence to the driver.
- **Driver (`axi_lite_driver`)**: Drives the transactions to the DUT.
- **Monitor (`axi_lite_monitor`)**: Observes and checks the DUT's behavior.
- **Environment (`axi_lite_env`)**: Connects the sequencer, driver, and monitor.
- **Test (`axi_lite_test`)**: Configures and runs the test.
- **Top-Level Module (`top`)**: Instantiates the DUT and UVM testbench.

This full structure should give you a clear and detailed understanding of how each component interacts in a UVM-based testbench for the AXI Lite protocol.


