INITIALISATION:

i = 0
loop_i:
	j = 0;
loop_j: 
 
//CALLING AXI READ:
  dram_addr0 = dram_row_ptr0*(this->width)/4;
  dram_addr1 = dram_row_ptr1*(this->width)/4;
  burst_len = width/4;

  //sve dok ne stigne prvi podatak na ulaz demux-a ne radimo nista
  while(en = 0);

k = 0;
loop_k:       

        goto DRAM_TO_BRAM; (i, j, k)

        k = k + 1;
        //saljemo po 4 podatka odjednom po HP portu
        if(k = width/4) then
          goto end_k;
        else
          goto loop_k;
end_k: 

      dram_row_ptr0 += 2;
      dram_row_ptr1 += 2;
      sel_dram += 1;

      if(sel_dram = 8)
	      sel_dram = 0;

      if(dram_row_ptr1=height) then
        goto end_i;
      else
        goto cont;
cont:		
      j = j + 2;
      if(j = BRAM_HEIGHT) then
        goto end_j;
      else
        goto loop_j;
end_j:  
  i = i + 1;
  if(i = floor(2*BRAM_WIDTH/width)) then 
    goto end_i;
  else
    goto loop_i;
end_i:

if(init){
  goto CONTROL_LOGIC;
}else{
  goto BACK_FROM_REINIT;
}

------------------------------------------------------------------------------------------------------
 
CONTROL_LOGIC:
i = 0;

sel_bram = 0;
sel_dram = 0;
sel_core = 0;
sel_bram_out = 0;
sel_dram_out = 0;
dram_row_ptr0 = 0;
dram_row_ptr1 = 1;
offset_core = 0;

loop_i:
      cycle_number = ((int)i/BRAM_HEIGHT)%((int)2*BRAM_WIDTH/width);  
      bram_block_ptr = i%BRAM_HEIGHT;  

      if(cycle_number = (floor(2*BRAM_WIDTH/width)-1) && bram_block_ptr = 12) then
        if(dram_row_ptr1<height) then
          
          counter_init++;
          dram_row_ptr0 = (floor(2*BRAM_WIDTH/width)*BRAM_HEIGHT - (BRAM_HEIGHT-bram_block_ptr)) * counter_init;
          dram_row_ptr1 = (floor(2*BRAM_WIDTH/width)*BRAM_HEIGHT - (BRAM_HEIGHT-bram_block_ptr)) * counter_init + 1;
         
          //konstante ne mora se realizovati kao oduzimanje 16-12 = 4
          i+=(BRAM_HEIGHT-bram_block_ptr);
          cycle_number = ((int)i/BRAM_HEIGHT)%((int)2*BRAM_WIDTH/width); 
          bram_block_ptr = i%BRAM_HEIGHT;

          sel_bram = 0;
          sel_dram = 0;
          sel_core = 0;
          offset_core = 0;

          init = 0;	  
          //zakasniti za broj klokova potrebnih da se posljednji podatak upise u BRAM
          //provjeriti da li je posljednji put SEND_TO_BRAM rijeseno ne treba INITIALIZATION
          //odnosno nece uci u SEND_TO_DRAM zbog if uslova...
          //dodatan uslov u SEND_TO_DRAM
          goto INITIALISATION and SEND_TO_DRAM;
        else
          goto SEND_TO_DRAM; // rijeseno ovim valjda...
        end if;
      end if;

BACK_FROM_REINIT:

row_position = 0;
loop_j:      
        goto PIPELINE;

end_pipeline:

        row_position = row_position + 1;
        if(row_position = width/2 - 1) then
            goto end_j;
        else
            goto loop_j;
end_j: 
    
    sel_core = sel_core + 1;
    
    if(sel_core = 4){
	    sel_core = 0;
	    offset_core = offest_core + 1;
    }

    if(sel_bram = 4){
      sel_bram = 0;
    }else{
      sel_bram = sel_bram + 1;
    }
    i = i + PTS_PER_ROWS;
    if(i > floor(height/PTS_PER_ROWS)*PTS_PER_ROWS + accumulated_loss) then
        goto end_i;
    else
        goto loop_i;     
end_i:    

----------------------------------------------------------------------------------------------------------

DRAM_TO_BRAM:	

  bram_addr0_A = i*(this->width)/2 + k<<1; //0 2 4 6
  bram_addr0_B = i*(this->width)/2 + k<<1+1; //1 3 5 7
  
  bram_addr1_A = i*(this->width)/2 + k<<1;
  bram_addr1_B = i*(this->width)/2 + k<<1+1;

  switch(sel_dram)
  case 0:
  	bram_block0 = HP0;
	  bram_block1 = HP1;
  case 1:
  	bram_block2 = HP0;
	  bram_block3 = HP1;
  .....
  case 7:
	  bram_block14 = HP0;
	  bram_block15 = HP1;

  
--------------------------------------------------------------------------------------------------------
PIPELINE:

BRAM_INTO_INPUT: (bram_block_ptr, cycle_num, row_position, addr_filter)

if(sel_bram = 3){
  bram_block_A/B[12..15][row_position + cycle_num*width/2];
  bram_block_A/B[0...1][row_position + ((cycle_num+1)%((int)(2*BRAM_WIDTH/width)))*width/2];
}else{
  //addr za sve blokove:
  bram_block_A/B[0...15][row_position + cycle_num*width/2];
}

//u svakom case-u se uvecavaju za 4 u odnosu na prvi case
switch(sel_bram){
    case 0:
      mux0_A = bram_block_A[0]; 
      mux0_B = bram_block_B[0];
      mux1_A = bram_block_A[1];
      mux1_B = bram_block_B[1];
      ...
      mux5_A = bram_block_A[5];
      mux5_B = bram_block_B[5];
    break;

    case 1:
      mux0_A = bram_block_A[4];
      mux0_B = bram_block_B[4];
      mux1_A = bram_block_A[5];
      mux1_B = bram_block_B[5];
      ...
      mux5_A = bram_block_A[9];
      mux5_B = bram_block_B[9];
    break;
   
    case 2:
      mux0_A = bram_block_A[8];
      mux0_B = bram_block_B[8];
      mux1_A = bram_block_A[9];
      mux1_B = bram_block_B[9];
      ...
      mux5_A = bram_block_A[13];
      mux5_B = bram_block_B[13];
    break;

    case 3:
      mux0_A = bram_block_A[12];
      mux0_B = bram_block_B[12];
      mux1_A = bram_block_A[13];
      mux1_B = bram_block_B[13];
      ...
      mux4_A = bram_block_A[0];
      mux4_B = bram_block_B[0];
      mux5_A = bram_block_A[1];
      mux5_B = bram_block_B[1];
    break; 

    default:
      break;
  }

	

------------------------------------------------------------------------------------------------------
FILTER:

//x prvi put po svim kolonama
temp[0] = mux(1-4)A(15-0)*2 + mux(2-5)A(15-0);
temp[1] = mux(1-4)B(15-0)*(-2) + mux(0-4)A(15-0);
temp[2] = mux(0-3)B*(15-0)*(-1) - mux(2-5)B(15-0);

mem18[0] = temp[0]+temp[1]+temp[2];

//x drugi put po svim kolonama
temp[0] = mux(1-4)A(31-16)*2 + mux(2-4)A(31-16);
temp[1] = mux(1-4)B(31-16)*(-2) + mux(0-3)A(31-16);
temp[2] = mux(0-3)B*(31-16)*(-1) - mux(2-5)B(31-16);

mem18[1] = temp[0]+temp[1]+temp[2];
.....

//y prvi put po svim kolonama
temp[3] = mux(0-3)A(31-16)*2 + mux(0-3)B(15-0);
temp[4] = mux(2-5)A(31-16)*(-2) + mux(0-3)A(15-0);
temp[5] = mux(2-5)A(15-0)*(-1) - mux(2-5)B(15-0);

mem18[8] = temp[3]+temp[4]+temp[5];

//y drugi put po svim kolonama
temp[3] = mux(0-3)B(15-0)*2 + mux(0-3)B(31-16);
temp[4] = mux(2-5)B(15-0)*(-2) + mux(0-3)A(31-16);
temp[5] = mux(2-5)A(31-16)*(-1) - mux(2-5)B(31-16);

mem18[9] = temp[3]+temp[4]+temp[5];
......

---------------------------------------------------------------------------------------------------------
IP_TO_BRAM:

//paziti da row_position prolazi kroz registre IP
//cycle_num UMJESTO offest_core ?????????

bram_output_x_addr = row_position + width*offset_core;
bram_output_y_addr = row_position + width*offset_core;

switch(sel_core)
//za x, analogno y
case 0:
	bram_block0 = demux0
	bram_block1 = demux1
	bram_block2 = demux2
	bram_block3 = demux3
case 1:
	bram_block4 = demux0
	bram_block5 = demux1
	bram_block6 = demux2
	bram_block7 = demux3	
case 2:
	bram_block8 = demux0
	bram_block9 = demux1
	bram_block10 = demux2
	bram_block11 = demux3
case 3:
	bram_block12 = demux0
	bram_block13 = demux1
	bram_block14 = demux2
	bram_block15 = demux3

------------------------------------------------------------------------------------------------------
BRAM_TO_DRAM:

//analogno za y 1 veliki mux
switch(sel_bram_out)
case 0:
	mux_out = bram_block0;
case 1: 
	mux_out = bram_block1;
.....
case 15:
	mux_out = bram_block15;

//pocetne adr dram/bram
burst_len = floor((width-2)/4); // ako je 256 to je max sirina reda jer smo rekli da je red 1024*16bit, a 256*64 = 1024*16
// ne moze se rijesiti problem slanja 37.5 podataka jer svakako u DRAM-u moramo imati 38 lokacija kako bismo ubacili
// rj: rijesiti problem preko softvera prilikom citanja posljednjeg podatka.

//row_position_read = odredjuje ukupan broj redova u citavom izlaznom BRAM 16
//row_batch_cnt_read = odredjuje lokaciju 

i = 0;
loop i:
  sel_dram_out = 0;
loop sel_dram_out:
  k = 0;
loop k:
    dram_addr_x = width*height + row_batch_cnt_read*ceil((width-2)/4) + row_position_read*ceil((width-2)/4) + counter_od_axi;
    bram_addr_x/y(sel_dram_out) = i*ceil((width-2)/2) + k;
    dram_addr_y = width*height + (width-2)*(height-2) +row_batch_cnt_read*ceil((width-2)/4) +  row_position_read*ceil((width-2)/4) + counter_od_axi;
    k = k + 1;
    if(k = (width - 2)/2)
      goto end_k
    else
      goto loop_k
end_k:
  row_position_read++;
  sel_dram_out = sel_dram_out + 1;
  if(sel_dram_out = 16)
    goto end_sel_dram_out
  else
    goto sel_dram_out
end_sel_dram_out:
  i = i + 1;
  if(i = floor(2*BRAM_WIDTH/(width-2)))
    goto end_i
  else
    loop_i
end_i:
row_batch_cnt_read+= row_position_read;
row_position_read = 0;
//nastavi od control logic
------------------------------------------------------------------------------------------------------
